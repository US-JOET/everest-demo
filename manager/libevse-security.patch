diff --git a/lib/evse_security/crypto/openssl/openssl_supplier.cpp b/lib/evse_security/crypto/openssl/openssl_supplier.cpp
index 3347b88..ee4f550 100644
--- a/lib/evse_security/crypto/openssl/openssl_supplier.cpp
+++ b/lib/evse_security/crypto/openssl/openssl_supplier.cpp
@@ -591,25 +591,7 @@ CertificateValidationResult OpenSSLSupplier::x509_verify_certificate_chain(
         }
     }
 
-    X509_STACK_UNSAFE_ptr untrusted = nullptr;
-
-    // Build potentially untrusted intermediary (subca) certificates
-    if (false == untrusted_subcas.empty()) {
-        untrusted = X509_STACK_UNSAFE_ptr(sk_X509_new_null());
-        int flags = X509_ADD_FLAG_NO_DUP | X509_ADD_FLAG_NO_SS;
-
-        for (auto& untrusted_cert : untrusted_subcas) {
-            if (1 != X509_add_cert(untrusted.get(), get(untrusted_cert), flags)) {
-                EVLOG_error << "X509 could not create untrusted store stack!";
-                return CertificateValidationResult::Unknown;
-            }
-        }
-    }
-
-    if (1 != X509_STORE_CTX_init(store_ctx_ptr.get(), store_ptr.get(), get(target), untrusted.get())) {
-        EVLOG_error << "X509 could not init x509 store ctx!";
-        return CertificateValidationResult::Unknown;
-    }
+    X509_STORE_CTX_init(store_ctx_ptr.get(), store_ptr.get(), get(target), NULL);
 
     if (allow_future_certificates) {
         // Manually check if cert is expired
